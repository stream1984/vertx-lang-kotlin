= vertx-lang-kotlin-coroutine

The `vertx-lang-kotlin-coroutine` integrates Kotlin _coroutines_ for performing asynchronous operations and processing events.
This results in using a programming model that looks like sequential code, yet it does not block kernel threads.

== Introduction

One of the key advantages of Vert.x over many legacy application platforms is that it is almost entirely non-blocking
(of kernel threads).
This allows Vert.x-based applications to handle a lot of concurrency (e.g., many connections and messages) using a very small number of kernel threads, which in turns unlocks great scalability.

The non-blocking nature of Vert.x leads to asynchronous APIs.
Asynchronous APIs can take various forms including callbacks, promises, fibers or reactive extensions.
Vert.x uses the callback style for the core APIs but it also supports other models like RxJava 1 and 2.

In some cases, programming using asynchronous APIs can be more challenging than using a classic / sequential style of code, in
particular with several operations need to be done in sequence.
Also, error propagation is often more complex when using asynchronous APIs.

`vertx-lang-kotlin-coroutine` uses _coroutines_.
Coroutines are very lightweight threads that do not correspond to underlying kernel threads, so that when a _coroutine_ needs to _"block_" it gets _suspended_ and frees its current kernel thread so that another coroutine can process events.

`vertx-lang-kotlin-coroutine` uses https://github.com/Kotlin/kotlinx.coroutines[kotlinx.coroutines] to implement the Coroutines.

NOTE: `vertx-lang-kotlin-coroutine` currently only works with Kotlin.

== Running a coroutine from a Vert.x context

Having imported `io.vertx.kotlin.coroutines.VertxCoroutine`, the `runCoroutine` extension method allows running a block of code as a coroutine that can be suspended:

[source,kotlin,indent=0]
----
include::../../kotlin/example/Example.kt[tags=runCoroutineExample]
----

The `asyncEvent` function suspends the execution of the coroutine until the timer fires and returns the value that was given to the handler.
More details are given in the next sections on handlers, events and stream of events.

== Extending CoroutineVerticle

You can deploy your code as instances of `io.vertx.ext.coroutine.CoroutineVerticle`, a specialized type of verticle for Kotlin coroutines.
You should override the `start()` and (optionally) the `stop()` methods of the verticle:

[source,kotlin,indent=0]
----
include::../../kotlin/example/Example.kt[tags=CoroutineVerticle]
----

== Getting one-shot asynchronous results

Many asynchronous operations in Vert.x take a `Handler<AsyncResult<T>>` as the last argument.
An example would be executing an object retrieval using the Vert.x Mongo client, or sending an event bus message then awaiting for a reply.

This is done by using the `asyncResult` method which returns deferred value.
The coroutine is being suspended until the event is being processed, and no kernel thread is being blocked.

The method is executed by specifying the asynchronous operation that needs to be executed in the form of a block that is passed to the handler at run-time.

Here is an example:

[source,kotlin,indent=0]
----
include::../../kotlin/example/Example.kt[tags=asyncResult]
----

== Getting one-shot events

Processing a one-shot event (and not the next occurrences, if any) is done using the `asyncEvent` function:

[source,kotlin,indent=0]
----
include::../../kotlin/example/Example.kt[tags=asyncEvent]
----

== Streams of events

In many places in Vert.x APIs, streams of events are processed through handlers.
Examples include event bus message consumers and HTTP server requests.

The `ReceiveChannelHandler` class allows receiving events through the (suspendable) `receive` method:

[source,kotlin,indent=0]
----
include::../../kotlin/example/Example.kt[tags=streamExample]
----

== Handlers outside of suspendable code

It can be the case that handler code is being set up from outside of suspendable code.

This is the case of the following method, and the solution is again to wrap such code in a `runCoroutine` call:

[source,kotlin,indent=0]
----
include::../../kotlin/example/Example.kt[tags=handlerAndCoroutine]
----

== Awaiting the completion of Vert.x futures

The `await` extension method on instances of Vert.x future objects suspend coroutines until they have completed, in which case the method returns the corresponding `AsyncResult<T>` object.

[source,kotlin,indent=0]
----
include::../../kotlin/example/Example.kt[tags=awaitingFuture]
----
